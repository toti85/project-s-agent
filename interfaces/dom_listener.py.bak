"""
DOMListener for Project-S
Integrates robust DOM-based command detection and response sending for AI interfaces (ChatGPT, Claude, Gemini, Copilot).
Adapted from tested logic in dom_handler_test.py.
"""
import time
import logging
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys

logger = logging.getLogger("DOM_Listener")

class DOMListener:
    COMMAND_PREFIXES = ("CMD:", "CODE:", "INFO:", "FILE:", "TEST:", "COMMAND:", "S_CMD:", "EXECUTE:", "TASK:")

    def __init__(self, driver):
        self.driver = driver
        self.active_interface = None
        self.last_dom_scan = 0
        self.dom_scan_interval = 0.3
        self.last_command = ""
        self.last_timestamp = 0
        self.command_cooldown = 3
        self.recent_commands = set()
        self.max_recent_commands = 5
        # DOM command listener task v√°zlat
        self._listener_task = None
        # Parancs menedzsment
        self.dom_command_listener = None
        # Detekt√°ljuk az akt√≠v interf√©szt
        self._detect_active_interface()

    def _detect_active_interface(self):
        try:
            current_url = self.driver.current_url.lower()
            if "chat.openai.com" in current_url:
                self.active_interface = "chatgpt"
            elif "claude.ai" in current_url:
                self.active_interface = "claude"
            elif "gemini" in current_url or "bard" in current_url:
                self.active_interface = "gemini"
            elif "copilot" in current_url:
                self.active_interface = "copilot"
            else:
                self.active_interface = "unknown"
            logger.info(f"Detected interface: {self.active_interface}")
        except Exception as e:
            logger.error(f"Error detecting interface: {e}")
            self.active_interface = "unknown"

    def detect_commands(self):
        """
        Parancsok felismer√©se a DOM-ban t√∂bb strat√©gia haszn√°lat√°val.
        
        T√°mogatott parancs form√°tumok:
        1. [S_COMMAND]{...}[/S_COMMAND] blokkok
        2. PREFIX: tartalom form√°tum√∫ parancsok (CMD:, CODE:, stb.)
        3. JSON form√°tum√∫ parancsok speci√°lis blokkokban
        
        Returns:
            str: A detekt√°lt parancs sz√∂vege, vagy √ºres string ha nincs parancs
        """
        now = time.time()
        if now - self.last_dom_scan < self.dom_scan_interval:
            return ""
        
        self.last_dom_scan = now
        self._detect_active_interface()
        
        last_detected_command = None
        
        # Interf√©sz-specifikus detekt√°l√°si strat√©gi√°k
        if self.active_interface == "chatgpt":
            # El≈ësz√∂r keress√ºnk S_COMMAND blokkokat
            command = self._detect_s_command_blocks()
            if command:
                last_detected_command = command
            
            # Ha nincs S_COMMAND blokk, keres√ºnk m√°s parancs form√°tumokat
            for strategy in [self._detect_from_assistant_role, self._detect_from_markdown]:
                if not last_detected_command:
                    command = strategy()
                    if command:
                        last_detected_command = command
        
        elif self.active_interface == "claude":
            # Claude-specifikus detekt√°l√°s
            command = self._detect_s_command_blocks()
            if command:
                last_detected_command = command
            else:
                command = self._detect_from_claude()
                if command:
                    last_detected_command = command
        
        elif self.active_interface == "gemini" or self.active_interface == "copilot":
            # Gemini/Copilot-specifikus detekt√°l√°s
            command = self._detect_s_command_blocks()
            if command:
                last_detected_command = command
            else:
                command = self._detect_from_text_base()
                if command:
                    last_detected_command = command
        
        else:
            # √Åltal√°nos strat√©gi√°k minden m√°s interf√©szn√©l
            for strategy in [
                self._detect_s_command_blocks,
                self._detect_from_assistant_role, 
                self._detect_from_text_base, 
                self._detect_from_markdown, 
                self._detect_via_javascript
            ]:
                command = strategy()
                if command:
                    last_detected_command = command
                    break
        
        # Ellen≈ërizz√ºk, hogy √∫j parancs-e
        if last_detected_command and self._is_new_command(last_detected_command, now):
            logger.info(f"√öj parancs detekt√°lva: {last_detected_command[:30]}...")
            return last_detected_command
        
        return ""

    def _detect_s_command_blocks(self):
        """
        [S_COMMAND] blokkok keres√©se a DOM-ban.
        A blokkok lehetnek:
        1. [S_COMMAND]{...}[/S_COMMAND] - JSON tartalommal
        2. [S_COMMAND]parancs[/S_COMMAND] - Sz√∂veges tartalommal
        """
        try:
            # JavaScript keres≈ëscript a parancsblokkok detekt√°l√°s√°ra
            script = """
            function findCommandBlocks() {
                // DOM text elemek keres√©se
                let elements = document.querySelectorAll('div, p, span, pre, code');
                let text = '';
                
                // Az √∂sszes elem sz√∂veg√©nek vizsg√°lata
                for (let el of elements) {
                    const content = el.textContent || '';
                    if (content.includes('[S_COMMAND]') && content.includes('[/S_COMMAND]')) {
                        // Teljes tartalmat visszaadjuk, ha tartalmazza a blokkot
                        return content;
                    }
                    
                    // Ha az elem r√©sze lehet egy nagyobb blokknak, √∂sszegy≈±jtj√ºk a sz√∂veget
                    if (content.includes('[S_COMMAND]') || content.includes('[/S_COMMAND]')) {
                        text += content + '\\n';
                    }
                }
                
                // M√©g megpr√≥b√°lunk egy teljes DOM keres√©st
                const fullText = document.body.textContent || '';
                if (fullText.includes('[S_COMMAND]') && fullText.includes('[/S_COMMAND]')) {
                    const startIndex = fullText.indexOf('[S_COMMAND]');
                    const endIndex = fullText.indexOf('[/S_COMMAND]', startIndex) + '[/S_COMMAND]'.length;
                    if (startIndex >= 0 && endIndex > startIndex) {
                        return fullText.substring(startIndex, endIndex);
                    }
                }
                
                return text.length > 0 ? text : '';
            }
            return findCommandBlocks();
            """
            
            result = self.driver.execute_script(script)
            if result:
                # Ha tartalmazza a blokk jel√∂l≈ëket
                if '[S_COMMAND]' in result and '[/S_COMMAND]' in result:
                    return result
            
            return ""
            
        except Exception as e:
            logger.debug(f"Hiba az S_COMMAND blokkok keres√©se sor√°n: {e}")
            return ""

    def _detect_from_assistant_role(self):
        try:
            elements = self.driver.find_elements(By.CSS_SELECTOR, "div[data-message-author-role='assistant'] div.markdown")
            for el in reversed(elements):
                text = el.text.strip()
                if text.startswith(self.COMMAND_PREFIXES):
                    return text
        except Exception:
            pass
        return ""

    def _detect_from_text_base(self):
        try:
            elements = self.driver.find_elements(By.CSS_SELECTOR, "div.text-base")
            for el in reversed(elements):
                text = el.text.strip()
                if text.startswith(self.COMMAND_PREFIXES):
                    return text
        except Exception:
            pass
        return ""

    def _detect_from_markdown(self):
        try:
            elements = self.driver.find_elements(By.CSS_SELECTOR, ".markdown, .prose")
            for el in reversed(elements):
                text = el.text.strip()
                if text.startswith(self.COMMAND_PREFIXES):
                    return text
        except Exception:
            pass
        return ""

    def _detect_from_claude(self):
        try:
            elements = self.driver.find_elements(By.CSS_SELECTOR, ".claude-message-content, .message-content")
            for el in reversed(elements):
                text = el.text.strip()
                if text.startswith(self.COMMAND_PREFIXES):
                    return text
            elements = self.driver.find_elements(By.CSS_SELECTOR, ".message[data-message-author-type='ai']")
            for el in reversed(elements):
                text = el.text.strip()
                if text.startswith(self.COMMAND_PREFIXES):
                    return text
        except Exception:
            pass
        return ""

    def _detect_via_javascript(self):
        try:
            script = '''
            const prefixes = ["CMD:", "CODE:", "INFO:", "FILE:", "TEST:"];
            let allTextElements = document.querySelectorAll('div, p, span, pre');
            for (let i = allTextElements.length - 1; i >= 0; i--) {
                const text = allTextElements[i].textContent.trim();
                for (const prefix of prefixes) {
                    if (text.startsWith(prefix)) {
                        return text;
                    }
                }
            }
            return "";
            '''
            return self.driver.execute_script(script)
        except Exception:
            return ""

    def _is_new_command(self, command, now):
        if not command or not command.startswith(self.COMMAND_PREFIXES):
            return False
        prefix = next((p for p in self.COMMAND_PREFIXES if command.startswith(p)), "")
        if len(command.strip()) <= len(prefix):
            return False
        if "FORCE:" in command[:15]:
            self.last_timestamp = now
            return True
        if (now - self.last_timestamp) <= self.command_cooldown:
            return False
        if command in self.recent_commands:
            return False
        self.recent_commands.add(command)
        if len(self.recent_commands) > self.max_recent_commands:
            self.recent_commands.pop()
        self.last_timestamp = now
        return True

    def send_response(self, message):
        """
        V√°lasz k√ºld√©se az AI interf√©szbe, az aktu√°lisan detekt√°lt interf√©sz t√≠pus alapj√°n.
        Ha nem siker√ºl az els≈ëdleges m√≥dszerrel k√ºldeni, akkor kipr√≥b√°l m√°sodlagos m√≥dszereket is.
        
        Args:
            message (str): A k√ºldend≈ë √ºzenet sz√∂vege
            
        Returns:
            bool: True ha sikeres volt a k√ºld√©s, False egy√©bk√©nt
        """
        # Ha nincs akt√≠v interf√©sz, pr√≥b√°ljuk √∫jradetekt√°lni
        if not self.active_interface or self.active_interface == "unknown":
            self._detect_active_interface()
        
        # Konfigur√°lhat√≥ prefix, ami jel√∂li, hogy projekt v√°laszr√≥l van sz√≥
        response_prefix = "[Project-S] "
        
        # Interf√©sz-specifikus v√°lasz met√≥dusok, priorit√°s sorrendben
        send_methods = []
        
        if self.active_interface == "chatgpt":
            send_methods = [
                self._send_response_to_chatgpt,
                self._send_response_via_selenium,  # Fallback m√≥dszer
            ]
        elif self.active_interface == "claude":
            send_methods = [
                self._send_response_to_claude,
                self._send_response_via_selenium,  # Fallback m√≥dszer
            ]
        elif self.active_interface == "gemini":
            send_methods = [
                self._send_response_to_gemini,
                self._send_response_via_selenium,  # Fallback m√≥dszer
            ]
        elif self.active_interface == "copilot":
            send_methods = [
                self._send_response_to_copilot,
                self._send_response_via_selenium,  # Fallback m√≥dszer
            ]
        else:
            send_methods = [self._send_response_via_selenium]
        
        # Pr√≥b√°ljuk meg az √∂sszes met√≥dust, am√≠g sikeres nem lesz
        message_with_prefix = response_prefix + message
        
        for send_method in send_methods:
            try:
                success = send_method(message_with_prefix)
                if success:
                    logger.info(f"V√°lasz sikeresen elk√ºldve a {self.active_interface} interf√©szbe")
                    return True
            except Exception as e:
                logger.warning(f"Hiba a {send_method.__name__} haszn√°lata sor√°n: {e}")
                continue
        
        logger.error(f"Egyik v√°laszk√ºld√©si m√≥dszer sem m≈±k√∂d√∂tt a {self.active_interface} interf√©szhez")
        return False

    def _send_response_to_chatgpt(self, message):
        return self._send_response_generic(message, [
            "#prompt-textarea", "textarea[data-id='prompt-textarea']", "textarea.m-0", "textarea[placeholder*='Send a message']", "textarea[tabindex='0']"
        ], [
            "button[data-testid='send-button']", "button.absolute.p-1", "button[class*='bottom-right']", "button[type='submit']"
        ])

    def _send_response_to_claude(self, message):
        return self._send_response_generic(message, [
            "textarea[placeholder*='Message Claude']", "textarea.w-full", "textarea.resize-none", "textarea[placeholder*='Send a message']", "textarea.h-full", "[contenteditable='true']"
        ], [
            "button[aria-label='Send message']", "button.rounded-full", "button.absolute.right-", "button[type='submit']"
        ])

    def _send_response_to_gemini(self, message):
        return self._send_response_generic(message, [
            "textarea[placeholder*='Enter your question']", "textarea.input-area", "textarea.message-input", "textarea.gemini-input"
        ], [
            "button[aria-label='Submit']", "button.send-button", "button.mdc-icon-button", "button[type='submit']"
        ])

    def _send_response_to_copilot(self, message):
        return self._send_response_generic(message, [
            "textarea.input-area", "textarea[placeholder*='Ask me anything']", "textarea.copilot-input", "textarea[aria-label='Ask Copilot']"
        ], [
            "button.send-button", "button[aria-label='Send']", "button.action-button", "button[type='submit']"
        ])

    def _send_response_via_selenium(self, message):
        return self._send_response_generic(message, [
            "#prompt-textarea", "textarea[data-id='prompt-textarea']", "textarea.m-0", "textarea[placeholder*='Send a message']", "textarea[placeholder*='Message']", "textarea[tabindex='0']", "textarea"
        ], [
            "button[data-testid='send-button']", "button[aria-label='Send message']", "button.absolute.p-1", "button[class*='bottom-right']", "button[type='submit']"
        ])

    def _send_response_generic(self, message, textarea_selectors, button_selectors):
        message = self._sanitize_text(message)
        message = "[DOM-Test] " + message
        textarea = self._find_element_with_selectors(textarea_selectors)
        if not textarea:
            logger.error("Textarea not found for response send")
            return False
        if not self._insert_text_with_fallbacks(textarea, message):
            logger.error("Failed to insert text into textarea")
            return False
        if not self._click_button_with_fallbacks(button_selectors, textarea):
            logger.error("Failed to click send button")
            return False
        return True

    def _sanitize_text(self, text):
        emoji_map = {'‚úîÔ∏è': '[OK]', 'üîç': '[SEARCH]', '‚≠ê': '[STAR]', 'üöÄ': '[ROCKET]', 'üìù': '[WRITE]', '‚è≥': '[TIMER]', '‚úÖ': '[CHECK]', '‚ùå': '[X]', '‚ö†Ô∏è': '[WARNING]', 'üí´': '[SPARKLE]', 'üî•': '[FIRE]', 'üåü': '[GLOW]', 'üåç': '[EARTH]'}
        for emoji, replacement in emoji_map.items():
            text = text.replace(emoji, replacement)
        return ''.join(c for c in text if ord(c) < 0x10000)

    def _find_element_with_selectors(self, selectors):
        for selector in selectors:
            try:
                element = WebDriverWait(self.driver, 5).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, selector))
                )
                if element:
                    return element
            except Exception:
                continue
        return None

    def _insert_text_with_fallbacks(self, textarea, message):
        try:
            self.driver.execute_script("arguments[0].scrollIntoView({ behavior: 'smooth', block: 'center' });", textarea)
            time.sleep(0.5)
            try:
                textarea.clear()
                time.sleep(0.2)
            except Exception:
                try:
                    self.driver.execute_script("arguments[0].value = '';", textarea)
                except Exception:
                    pass
            success = False
            try:
                textarea.send_keys(message)
                success = True
            except Exception:
                pass
            if not success:
                try:
                    self.driver.execute_script("""
                        const textarea = arguments[0];
                        const message = arguments[1];
                        textarea.value = message;
                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                        textarea.dispatchEvent(new Event('change', { bubbles: true }));
                    """, textarea, message)
                    success = True
                except Exception:
                    pass
            if not success:
                try:
                    import pyperclip
                    pyperclip.copy(message)
                    textarea.send_keys(Keys.CONTROL, 'v')
                    time.sleep(0.2)
                    success = True
                except Exception:
                    pass
            return success
        except Exception:
            return False

    def _click_button_with_fallbacks(self, button_selectors, textarea=None):
        try:
            send_button = None
            for selector in button_selectors:
                try:
                    send_button = WebDriverWait(self.driver, 5).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
                    )
                    if send_button:
                        break
                except:
                    continue
            if send_button:
                try:
                    self.driver.execute_script("arguments[0].click();", send_button)
                    time.sleep(0.5)
                    return True
                except Exception:
                    try:
                        send_button.click()
                        time.sleep(0.5)
                        return True
                    except Exception:
                        try:
                            from selenium.webdriver.common.action_chains import ActionChains
                            actions = ActionChains(self.driver)
                            actions.move_to_element(send_button).click().perform()
                            time.sleep(0.5)
                            return True
                        except Exception:
                            pass
            if textarea:
                try:
                    textarea.send_keys(Keys.RETURN)
                    time.sleep(0.5)
                    return True
                except Exception:
                    pass
            return False
        except Exception:
            return False

    def _reconnect_browser(self):
        """
        √öjracsatlakoz√°s a b√∂ng√©sz≈ëh√∂z ha a kapcsolat megszakadt vagy √©rv√©nytelen lett.
        """
        try:
            logger.info("√öjracsatlakoz√°si k√≠s√©rlet a b√∂ng√©sz≈ëh√∂z...")
            
            # R√©gi driver bez√°r√°sa, ha l√©tezik
            try:
                if hasattr(self, 'driver') and self.driver:
                    self.driver.quit()
            except Exception as e:
                logger.debug(f"Hiba a driver bez√°r√°s√°n√°l: {e}")
                
            # V√°runk egy kicsit az √∫jracsatlakoz√°s el≈ëtt
            time.sleep(2)
            
            # √öj driver inicializ√°l√°sa
            self.driver = get_default_driver()
            
            if self.driver:
                # Interf√©sz detekt√°l√°sa
                self._detect_active_interface()
                logger.info(f"Sikeresen √∫jracsatlakoztunk a b√∂ng√©sz≈ëh√∂z, interf√©sz: {self.active_interface}")
                return True
            else:
                logger.error("Nem siker√ºlt √∫jracsatlakozni a b√∂ng√©sz≈ëh√∂z")
                return False
                
        except Exception as e:
            logger.error(f"√öjracsatlakoz√°si hiba: {e}")
            return False
    
    def _safely_execute_browser_operation(self, operation_func, *args, **kwargs):
        """
        Biztons√°gosan hajt v√©gre egy b√∂ng√©sz≈ë m≈±veletet, √©s automatikusan √∫jracsatlakozik hiba eset√©n.
        
        Args:
            operation_func: A v√©grehajtand√≥ f√ºggv√©ny
            *args, **kwargs: A f√ºggv√©nynek √°tadand√≥ param√©terek
            
        Returns:
            A f√ºggv√©ny visszat√©r√©si √©rt√©ke, vagy None hiba eset√©n
        """
        max_retries = 2
        
        for attempt in range(max_retries):
            try:
                # Ellen≈ërizz√ºk, hogy a b√∂ng√©sz≈ë m√©g valid-e
                if self.driver:
                    try:
                        # Egyszer≈± ellen≈ërz√©s: lek√©rdezz√ºk az URL-t
                        current_url = self.driver.current_url
                    except Exception as e:
                        # Ha hiba t√∂rt√©nt, akkor val√≥sz√≠n≈±leg a driver m√°r √©rv√©nytelen
                        if "invalid session id" in str(e).lower():
                            logger.warning("√ârv√©nytelen b√∂ng√©sz≈ë session, √∫jracsatlakoz√°s...")
                            self._reconnect_browser()
                        else:
                            logger.error(f"B√∂ng√©sz≈ë m≈±velet hiba: {e}")
                
                # M≈±velet v√©grehajt√°sa
                return operation_func(*args, **kwargs)
                
            except Exception as e:
                if "invalid session id" in str(e).lower() and attempt < max_retries - 1:
                    logger.warning(f"√ârv√©nytelen b√∂ng√©sz≈ë session, √∫jracsatlakoz√°s ({attempt+1}/{max_retries})...")
                    self._reconnect_browser()
                else:
                    logger.error(f"B√∂ng√©sz≈ë m≈±velet hiba: {e}")
                    if attempt >= max_retries - 1:
                        return None
        
        return None

    # --- API for main.py compatibility ---    async def start(self):
        """
        Elind√≠tja a DOMListener-t √©s inicializ√°lja a DOM parancs figyel√©st
        """
        logger.info("DOMListener ind√≠t√°sa...")
        
        if self._listener_task is not None:
            logger.warning("A DOMListener m√°r fut, √∫jraind√≠t√°s...")
            await self.stop()
            
        # DOM parancsfigyel≈ë inicializ√°l√°sa
        try:
            import asyncio
            from core.command_router import router
            
            # Definin√°ljuk a dom_command_listener met√≥dust
            async def dom_command_listener_task():
                logger.info("DOM parancsfigyel≈ë elindult.")
                while True:
                    try:
                        # Parancsok keres√©se a DOM-ban a detekt√°l√°si strat√©gi√°kkal
                        command = self.detect_commands()
                        
                        # Ha tal√°ltunk parancsot, feldolgozzuk
                        if command:
                            logger.info(f"DOM parancs √©szlelve: {command[:50]}...")
                            result = await self.process_dom_command(command)
                            
                            # Ha van v√°lasz, visszak√ºld√©s az interf√©szbe
                            if result and isinstance(result, dict):
                                # V√°lasz √∂sszef≈±z√©se megfelel≈ë form√°tumra
                                response_text = f"[Project-S Response]\n{str(result)}"
                                success = self.send_response(response_text)
                                if success:
                                    logger.info("DOM v√°lasz sikeresen elk√ºldve")
                                else:
                                    logger.error("Nem siker√ºlt elk√ºldeni a DOM v√°laszt")
                    
                    except Exception as e:
                        logger.error(f"Hiba a DOM parancs figyel√©s sor√°n: {str(e)}")
                    
                    # V√°runk egy r√∂vid ideig a k√∂vetkez≈ë ellen≈ërz√©sig
                    await asyncio.sleep(1)
            
            # Periodikus parancsfigyel≈ë task ind√≠t√°sa - itt adjuk √©rt√©ket a dom_command_listener attrib√∫tumnak
            self.dom_command_listener = dom_command_listener_task
            self._listener_task = asyncio.create_task(dom_command_listener_task())
            
            logger.info("DOMListener sikeresen elindult")
            return True
            
        except Exception as e:
            logger.error(f"Hiba a DOMListener ind√≠t√°sa sor√°n: {str(e)}")
            return False    async def stop(self):
        """
        Le√°ll√≠tja a DOMListener-t √©s megszak√≠tja a fut√≥ folyamatokat
        """
        logger.info("DOMListener le√°ll√≠t√°sa...")
        
        try:
            # Listener task le√°ll√≠t√°sa, ha fut
            if self._listener_task and not self._listener_task.done():
                self._listener_task.cancel()
                logger.info("DOM parancsfigyel≈ë task le√°ll√≠tva")
            
            # WebDriver lez√°r√°sa, ha sz√ºks√©ges
            if hasattr(self, 'driver') and self.driver:
                try:
                    # Ne z√°rjuk be a b√∂ng√©sz≈ët, csak a kapcsolatot szak√≠tjuk meg
                    # a driver.quit() bez√°rn√° a b√∂ng√©sz≈ët is, ami nem k√≠v√°nt mell√©khat√°s lehet
                    pass
                except Exception as e:
                    logger.warning(f"Hiba a WebDriver lez√°r√°sa sor√°n: {str(e)}")
            
            logger.info("DOMListener sikeresen le√°ll√≠tva")
            return True
            
        except Exception as e:
            logger.error(f"Hiba a DOMListener le√°ll√≠t√°sa sor√°n: {str(e)}")
            return False

    async def process_dom_command(self, dom_command):
        """
        Feldolgoz egy DOM parancsot - kivonja a parancs adatokat,
        ellen≈ërzi a form√°tumot, √©s v√©grehajtja a megfelel≈ë m≈±veletet.
        
        T√°mogatott form√°tumok:
        1. [S_COMMAND]{JSON}[/S_COMMAND] - JSON form√°tum√∫ parancsblokk
        2. CMD:, CODE:, stb. prefix alap√∫ parancsok
        3. Nyers sz√∂veges parancsok megfelel≈ë prefix-szel
        
        Args:
            dom_command (str): A DOM-b√≥l sz√°rmaz√≥ nyers parancs sz√∂veg
            
        Returns:
            dict: A v√©grehajtott parancs eredm√©nye
        """
        logger.info(f"DOM parancs feldolgoz√°sa: {dom_command[:50]}...")
        
        try:
            # 1. [S_COMMAND] form√°tum√∫ parancsok kezel√©se
            if "[S_COMMAND]" in dom_command and "[/S_COMMAND]" in dom_command:
                # Parancs tartalom kinyer√©se a blokkb√≥l
                start_idx = dom_command.find("[S_COMMAND]") + len("[S_COMMAND]")
                end_idx = dom_command.find("[/S_COMMAND]")
                
                if start_idx > 0 and end_idx > start_idx:
                    command_content = dom_command[start_idx:end_idx].strip()
                    
                    try:
                        # JSON parancs feldolgoz√°sa
                        import json
                        cmd_data = json.loads(command_content)
                        
                        # Parancs t√≠pus √©s tartalom kinyer√©se
                        cmd_type = cmd_data.get("type", "").upper()
                        content = cmd_data.get("content", "")
                        query = cmd_data.get("query", "") # alternat√≠v mez≈ë neve
                        options = cmd_data.get("options", {})
                        
                        # Ha a content √ºres, de van query, akkor haszn√°ljuk azt
                        if not content and query:
                            content = query
                        
                        logger.info(f"DOM parancs t√≠pusa: {cmd_type}, tartalom: {content[:30]}...")
                        
                        # Parancs router integr√°ci√≥
                        from core.command_router import router
                        
                        # Parancs objektum √∂ssze√°ll√≠t√°sa a router sz√°m√°ra
                        command = {
                            "type": cmd_type,
                            "query": content,
                            "options": options
                        }
                        
                        # Parancs k√ºld√©se a routernek
                        return await router.route_command(command)
                    
                    except json.JSONDecodeError:
                        logger.warning(f"Nem JSON form√°tum√∫ S_COMMAND blokk, kezel√©s nyers sz√∂vegk√©nt")
                        
                        # Ha nem JSON, akkor kezelj√ºk nyers sz√∂vegk√©nt
                        from core.command_router import router
                        
                        command = {
                            "type": "ASK",  # Alap√©rtelmezett t√≠pus
                            "query": command_content
                        }
                        
                        return await router.route_command(command)
            
            # 2. "CMD:", "CODE:" √©s egy√©b el≈ëtag√∫ parancsok kezel√©se
            for prefix in self.COMMAND_PREFIXES:
                if dom_command.startswith(prefix):
                    cmd_type = prefix.strip(":")
                    content = dom_command[len(prefix):].strip()
                    
                    from core.command_router import router
                    
                    # Parancs objektum √∂ssze√°ll√≠t√°sa a router sz√°m√°ra
                    command = {
                        "type": cmd_type,
                        "query": content
                    }
                    
                    return await router.route_command(command)
            
            # Ha nem ismert parancs form√°tum, akkor pr√≥b√°lkozunk ASK parancst√≠pussal
            from core.command_router import router
            command = {
                "type": "ASK",
                "query": dom_command[:500]  # Limit√°ljuk a hosszt
            }
            
            logger.warning(f"Ismeretlen parancs form√°tum, ASK-k√©nt kezelj√ºk: {dom_command[:30]}...")
            return await router.route_command(command)
            
        except Exception as e:
            logger.error(f"Hiba a DOM parancs feldolgoz√°sa sor√°n: {str(e)}")
            return {"status": "error", "message": f"Feldolgoz√°si hiba: {str(e)}"}

# Provide a singleton dom_listener for import compatibility
from selenium import webdriver
import os
import subprocess
import time
import threading

def get_default_driver():
    """
    Inicializ√°lja a Selenium WebDriver-t a megfelel≈ë be√°ll√≠t√°sokkal.
    Ha lehets√©ges, egy m√°r fut√≥ b√∂ng√©sz≈ëh√∂z csatlakozik, k√ºl√∂nben √∫jat ind√≠t.
    """
    try:
        # El≈ësz√∂r pr√≥b√°ljunk csatlakozni egy m√°r fut√≥ b√∂ng√©sz≈ëh√∂z
        options = webdriver.ChromeOptions()
        options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
        
        try:
            # Chrome el√©r√©si √∫tvonal k√∂rnyezeti v√°ltoz√≥b√≥l vagy alap√©rtelmezett
            if os.environ.get("CHROME_DRIVER_PATH"):
                chrome_driver_path = os.environ.get("CHROME_DRIVER_PATH")
                service = webdriver.chrome.service.Service(executable_path=chrome_driver_path)
                driver = webdriver.Chrome(service=service, options=options)
            else:
                # Ha nincs megadva √∫tvonal, automatikus keres√©s
                driver = webdriver.Chrome(options=options)
                
            logger.info("Sikeresen csatlakoztunk egy fut√≥ Chrome b√∂ng√©sz≈ëh√∂z")
            return driver
            
        except Exception as e:
            logger.warning(f"Nem tudtunk csatlakozni fut√≥ b√∂ng√©sz≈ëh√∂z: {e}")
            
            # Ha nem siker√ºlt csatlakozni, ind√≠tsunk egy √∫j b√∂ng√©sz≈ët
            def start_chrome_process():
                chrome_path = os.environ.get("CHROME_PATH", "chrome")
                cmd = [
                    chrome_path,
                    "--remote-debugging-port=9222",
                    "--user-data-dir=./chrome-profile",
                    "--no-first-run",
                    "--no-default-browser-check"
                ]
                subprocess.Popen(cmd)
            
            # K√ºl√∂n sz√°lban ind√≠tsuk a b√∂ng√©sz≈ët, hogy ne blokkolja a f≈ësz√°lat
            thread = threading.Thread(target=start_chrome_process)
            thread.daemon = True  # A f≈ë program le√°ll√°s√°val ez a sz√°l is le√°ll
            thread.start()
            
            # V√°runk, hogy a b√∂ng√©sz≈ë elinduljon
            time.sleep(3)
            
            # √öjra pr√≥b√°ljunk csatlakozni
            options = webdriver.ChromeOptions()
            options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
            driver = webdriver.Chrome(options=options)
            
            logger.info("√öj Chrome b√∂ng√©sz≈ë elind√≠tva √©s csatlakoztatva")
            return driver
            
    except Exception as e:
        # Ha minden m√°s sikertelen, pr√≥b√°ljunk meg headless m√≥dban futtatni egy b√∂ng√©sz≈ët
        logger.error(f"Hiba a WebDriver inicializ√°l√°sa sor√°n: {e}")
        logger.info("Pr√≥b√°lkoz√°s headless Chrome b√∂ng√©sz≈ëvel...")
        
        try:
            options = webdriver.ChromeOptions()
            options.add_argument("--headless=new")  # Chrome 109+ sz√ºks√©ges az √∫j headless m√≥dhoz
            options.add_argument("--disable-gpu")
            options.add_argument("--window-size=1920,1080")
            driver = webdriver.Chrome(options=options)
            logger.info("Headless Chrome b√∂ng√©sz≈ë sikeresen inicializ√°lva")
            return driver
        except Exception as e2:
            logger.error(f"Nem siker√ºlt headless b√∂ng√©sz≈ët sem inicializ√°lni: {e2}")
            return None

# Singleton instance for main.py compatibility
try:
    # Ha van k√∂rnyezeti v√°ltoz√≥k√©nt be√°ll√≠tva, akkor ne pr√≥b√°ljunk driver-t l√©trehozni
    if os.environ.get("DOM_LISTENER_DISABLE") == "1":
        logger.warning("DOMListener l√©trehoz√°sa kihagyva (DOM_LISTENER_DISABLE=1)")
        dom_listener = None
    else:
        driver = get_default_driver()
        if driver:
            dom_listener = DOMListener(driver)
            logger.info("DOMListener singleton sikeresen l√©trehozva")
        else:
            # Ha nem siker√ºlt driver-t l√©trehozni, inicializ√°ljuk None-nal
            logger.warning("Nem siker√ºlt WebDriver-t inicializ√°lni, DOMListener korl√°tozott funkcionalit√°ssal")
            dom_listener = DOMListener(None)
except Exception as e:
    dom_listener = None
    logger.error(f"Nem siker√ºlt l√©trehozni a DOMListener singleton-t: {e}")
